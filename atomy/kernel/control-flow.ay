dynamic(labels, Hash new)

macro(if(x) then(&y) else(&z)):
  Atomy::AST::IfThenElse new(line, x, y body, z body)

macro(otherwise): 'true

macro(condition(&bs)):
  bs contents reverse inject('nil) [acc, `(~x -> ~y)]:
    `(if(~x) then: ~y; else: ~acc)

macro(return(y)):
  Atomy::AST::Return new(line, y)

macro(x rescue(&y)):
  Atomy::AST::Catch new(line, x caller, y contents)

macro(x rescue(&y) else(&z)):
  Atomy::AST::Catch new(line, x caller, y contents, z body)

macro(x ensuring(&y)):
  Atomy::AST::Ensure new(line, x caller, y body)

macro(when(c, &b)):
  Atomy::AST::When new(line, c, b body)

macro(unless(c, &b)):
  Atomy::AST::When new(line, `!~c, b body)

macro(super):
  Atomy::AST::ZSuper new(line)

macro(super(*args, &blk)):
  Atomy::AST::Super new(line, args, blk)

macro(yield):
  Atomy::AST::Yield new(line, [])

macro(yield(*args)):
  Atomy::AST::Yield new(line, args)

macro(break):
  Atomy::AST::Break new(line, 'nil)

macro(break(x)):
  Atomy::AST::Break new(line, x)

macro(next):
  Atomy::AST::Next new(line, 'nil)

macro(next(x)):
  Atomy::AST::Next new(line, x)

module(Atomy::AST):
  class(Labels < Node):
    children([#tags])
    generate

    bytecode(g) := do:
      pos(g)

      tags = ::Hash new

      labels =
        @tags collect [t]:
          tags [t method-name] = g new-label

      let(labels = tags):
        labels zip(@tags) each [[l, t]]:
          l set!
          t block body bytecode(g)
          g pop

      g push-nil

  class(GoTo < Node):
    attributes(#name)
    generate

    bytecode(g) := do:
      pos(g)
      g goto(^labels fetch(@name))

  class(ZSuper < Node):
    generate

    bytecode(g) := do:
      pos(g)

      g push-block

      if(g state super?)
        then:
          g zsuper(g state super name)
        else:
          g zsuper(nil)

  class(Super < Node):
    children([#arguments], #block?)
    generate

    bytecode(g) := do:
      pos(g)

      block = @block
      splat = nil

      args = 0
      @arguments each [a]:
        e = a prepare
        e match:
          BlockPass -> do:
            block =! e
            -- break

          Splat -> do:
            splat =! e
            -- break

          _ -> do:
            e bytecode(g)
            args += 1

      when(splat):
        splat compile(g)
        g cast-array

      if(block)
        then: block compile(g)
        else: g push-nil

      g send-super(nil, args, splat)

  class(Yield < Node):
    children([#arguments])
    generate

    bytecode(g) := do:
      pos(g)

      splat = nil

      args = 0
      @arguments each [a]:
        e = a prepare
        e match:
          Splat -> do:
            splat =! e
            -- break

          _ -> do:
            e bytecode(g)
            args += 1

      if(splat)
        then:
          splat compile(g)
          g cast-array
          g yield-splat(args)
        else:
          g yield-stack(args)

  class(Break < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g raise-break

  class(Next < Node):
    children(#value)
    generate

    bytecode(g) := do:
      pos(g)
      @value compile(g)
      g ret

macro(labels(&body)):
  `(let-macro(go(name) = Atomy::AST::GoTo new(line, name name)):
      ~(Atomy::AST::Labels new(line, body contents)))

macro(while(test, &body)):
  names [loop, done]:
    `(let-macro(break = 'go(~done),
                next = 'go(~loop)):
        labels:
          ~loop:
            unless(~test):
              go(~done)

            ~(body caller)
            go(~loop)

          ~done {})

macro(until(test, &body)):
  names [loop, done]:
    `(let-macro(break = 'go(~done),
                next = 'go(~loop)):
        labels:
          ~loop:
            when(~test):
              go(~done)

            ~(body caller)
            go(~loop)

          ~done {})

macro(loop(&body)):
  names [loop, done]:
    `(let-macro(break = 'go(~done),
                next = 'go(~loop)):
        labels:
          ~loop:
            ~(body caller)
            go(~loop)

          ~done {})
