macro(namespace(n: Variable)):
  `(evaluate-when(compile, run, load):
      Atomy::Namespace ensure(#~n))

macro(let-when(when, *bindings, &b)):
  tmps = names(bindings size)
  save = []
  set = []
  restore = []

  bindings zip(tmps) [[`(~n = ~v), tmp]]:
    save << `(Atomy::STATE [#~tmp] = ^~n)
    set << set-dynvar(n, v)
    restore << set-dynvar(n, `(Atomy::STATE delete(#~tmp)))

  names [res]:
    `(let(~*bindings):
        evaluate-when(~when):
          ~*save
          ~*set

        ~res = ~(b body)

        evaluate-when(~when):
          ~restore

        ~res)

macro(in-namespace(n, &b)):
  `(do:
      evaluate-when(load):
        Atomy::Namespace create(#~n)

      let-when(compile, namespace = Atomy::Namespace ensure(#~n)):
        ~(b body))

macro(no-namespace(&b)):
  `(let-when(compile, namespace = nil):
      ~(b body))

macro(export(&b)):
  `(let-when(compile, define-in = "_"):
      ~(b body))

macro(export-to(n, &b)):
  `(let-when(compile, define-in = ~(n name)):
      ~(b body))

macro(use(*ns)):
  current = Atomy::Namespace get
  where = current && current name

  `(evaluate-when(compile, run, load):
      ~*(ns collect [n]:
          `(Atomy::Namespace get(~where) use(#~n))))

macro(symbols(*ns)):
  current = Atomy::Namespace get
  where = current && current name

  `(evaluate-when(compile, run, load):
      ~*(ns collect [n]:
          `(Atomy::Namespace register(#~n, ~where))))
