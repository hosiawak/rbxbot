macro(do(&b)): b body

macro(x = y):
  Atomy::AST::Assign new(x line, x, y)

macro(x =! y):
  Atomy::AST::Set new(x line, x, y)

macro(x := y):
  where = Atomy::Namespace define-target
  Atomy::Namespace register(x namespace-symbol, where)

  Atomy::CodeLoader when-load <<
    [`(Atomy::Namespace register(~(x namespace-symbol), ~where)), true]

  Atomy::AST::Define new(x line, x, y, where)

macro(define(x, &y)):
  `(~x := ~(y block-body))

macro(x **= y): `(~x =! (~x ** ~y))
macro(x *= y): `(~x =! (~x * ~y))
macro(x <<= y): `(~x =! (~x << ~y))
macro(x >>= y): `(~x =! (~x >> ~y))
macro(x &&= y): `(~x =! (~x && ~y))
macro(x &= y): `(~x =! (~x & ~y))
macro(x ||= y): `(~x =! (~x || ~y))
macro(x |= y): `(~x =! (~x | ~y))
macro(x += y): `(~x =! (~x + ~y))
macro(x -= y): `(~x =! (~x - ~y))
macro(x /= y): `(~x =! (~x / ~y))
macro(x ^= y): `(~x =! (~x ^ ~y))
macro(x %= y): `(~x =! (~x % ~y))

macro(x match(&b)):
  Atomy::AST::Match new(line, x, b)

macro(class(`(<< ~obj), &body)):
  Atomy::AST::SingletonClass new(obj line, obj, body block-body)

macro(class(`(~name < ~sup), &body)):
  Atomy::AST::Class new(name line, name, body block-body, sup)

macro(class(name, &body)):
  Atomy::AST::Class new(name line, name, body block-body)

macro(module(name, &body)):
  Atomy::AST::Module new(name line, name, body block-body)

macro(evaluate-when('compile, 'run, 'load, &x)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  `(when(!(Atomy::CodeLoader compiled?) &&
          Atomy::CodeLoader reason == #run):
      ~*(x contents))

macro(evaluate-when('run, 'compile, &x)):
  x body evaluate
  `(when(!(Atomy::CodeLoader compiled?) &&
           Atomy::CodeLoader reason == #run):
      ~*(x contents))

macro(evaluate-when('compile, 'run, &x)):
  x body evaluate
  `(when(!(Atomy::CodeLoader compiled?) &&
           Atomy::CodeLoader reason == #run):
      ~*(x contents))

macro(evaluate-when('compile, 'load, &x)):
  x body evaluate
  Atomy::CodeLoader when-load << [x block-body, true]
  'nil

macro(evaluate-when('compile, &x)):
  x body evaluate
  'nil

macro(evaluate-when('run, &x)):
  `(when(Atomy::CodeLoader reason == #run) { ~*(x contents) })

macro(evaluate-when('load, &x)):
  Atomy::CodeLoader when-load << [x block-body, false]
  'nil

macro(for-macro(&b)):
  `(evaluate-when(compile, load):
      ~b block call-on-instance(Atomy::Macro::Environment singleton-class))

macro(let-macro(*ms, &body)):
  macros = ms collect [`(~p = ~b)]:
    Atomy::AST::Macro new(p line, p, b)

  Atomy::AST::LetMacro new(line, body caller, macros)
