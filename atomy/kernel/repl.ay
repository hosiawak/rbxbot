namespace(atomy)

title"The REPL"

require("readline")

doc"
  The basics of a REPL - reading, evaluating, and printing in a loop. More \
  flexibility is provided by various signals. See \hl{repl} for a fancier \
  REPL, which builds upon this, and \hl{ReplDebugger}.

  When showing the prompt, \hl{#prompt} is signaled with a \hl{#use-prompt} \
  restart available. Invoke this restart and pass along a string to \
  override the prompt, which defaults to \code{>>}.

  Input preceded by a colon (\code{:}) and followed by an alphanumeric \
  character is assumed to be a \italic{special command}. These are not \
  evaluated, and are signaled as \hl{#special(\italic{text})}.

  When the user sends \code{EOF} (Ctrl+D) or an interrupt (Ctrl+C), \
  \hl{#quit} is signaled.

  When the user enters code, \hl{#input(\italic{text})} is signaled. The code\
  is evaluated with two restarts registered: \code{#retry} for re-attempting \
  evaluation, and \code{#abort}, for canceling the evaluation. After the code\
  is evaluated, \hl{#evaluated(\italic{result})} is signaled.

  \hl{#loop} is signaled before the loop starts over again (i.e., after the \
  input is handled).
" spec {
  bnd is-a?(Binding)
} for:
  basic-repl(bnd = TOPLEVEL_BINDING) :=
    loop:
      prompt =
        with-restarts(use-prompt(p) -> p):
          signal(#prompt)
          ">> "

      in =
        { Readline readline(prompt)
        } rescue:
          Interrupt -> do { signal(#quit), "" }

      in match:
        nil -> signal(#quit)

        "" -> #ok

        String ? (=~ r"^:[[:alnum:]]") ->
          signal(#special(in [1 .. -1]))

        source -> do:
          signal(#input(source))

          try = {
            with-restarts(retry -> try [], abort -> #ok):
              res = Atomy::Compiler evaluate(source, bnd)
              signal(#evaluated(res))
          }

          try []

      signal(#loop)


doc"
  An interactive debugger REPL for handling errors. This will list the \
  results along with a number, allow the user to continue evaluating code, \
  and once they enter a \italic{special command} in the form of \
  \code{:\italic{number}}, the specified restart will be invoked.
" for:
  class(ReplDebugger):
    class(<< self):
      show-backtrace(e) := do:
        Rubinius::Backtrace backtrace(e backtrace) _/show print
        debug(e)

      run(e) := do:
        DefaultDebugger show-error-banner(e)

        with-restarts(backtrace -> show-backtrace(e)):
          debug(e)

      debug(e) := do:
        DefaultDebugger show-options-for(e)

        { basic-repl } bind:
          #prompt -> restart(#use-prompt, "[!]> ")

          #special(n ? (=~ r"\d+")) ->
            ^restarts [n to-i] invoke

          #quit -> exit(1)

dynamic(debugger, ReplDebugger)

doc"
  A more feature-filled REPL, providing persistent history and setting \
  \hl{^debugger} to \hl{ReplDebugger}.

  History will be managed and appended to a file specified by \hl{history} \
  upon termination.
" spec {
  history is-a?(String)
  bnd is-a?(Binding)
} for:
  repl(history = nil, bnd = TOPLEVEL_BINDING) := do:
    when(history && File exists?(history)):
      File open(history, "r") [f]:
        f readlines each [l]:
          Readline::HISTORY << l strip

    SANE_HISTORY = []

    { let(debugger = ReplDebugger):
        frame = 0

        { let(atomy/pretty/colored? = true):
            basic-repl(bnd)
        } bind:
          #prompt ->
            restart(#use-prompt, "[" + frame to-s + "]> ")

          #loop ->
            (frame += 1)

          #quit -> exit(0)

          #input(str) -> (SANE_HISTORY << str)

          #special("h") ->
            ":h\thelp" print

          #evaluated(r) ->
            (" => " + r show) print
    } ensuring:
      when(history):
        File open(history, "a") [f]:
          f puts(*SANE_HISTORY)
